"use server";
import { createClient } from "@/utils/supabase/server";
import type { Meeting } from "@/db/schema";
import { filterLinkcalEvents } from "./filterLinkCalEvents";
import { deduplicateEvents } from "./dedeuplicateEvents";
import {
  computeInsertData,
  computeUpdateData,
  computeDeletions,
} from "./computeMeetingDiffs";
import {
  deleteMeetings,
  insertMeetings,
  updateMeetings,
  updateLastSynced,
} from "./dbOperations";

/**
 * Synchronizes external calendar events with the local meetings database.
 *
 * Steps performed:
 * 1. Filter out events that were generated by Linkcal.
 * 2. Deduplicate the remaining events.
 * 3. Fetch existing meetings for comparison.
 * 4. Determine which events need insertion, update, or deletion.
 * 5. Perform the corresponding DB operations.
 * 6. Update the last_synced timestamp.
 *
 * @param validEvents - Array of external events to process.
 * @param accountId - The ID of the linked account.
 * @param userId - The user ID associated with these events.
 * @returns The deduplicated events if successful, otherwise null.
 */
export async function syncMeetingsToDatabase(
  validEvents: Omit<Meeting, "user_id" | "created_at" | "updated_at">[],
  accountId: string,
  userId: string
) {
  try {
    console.log("[syncMeetings.ts] Starting database sync...");

    // Step 1: Filter out Linkcal events.
    const nonLinkcalEvents = filterLinkcalEvents(validEvents);
    console.log(
      `[syncMeetings.ts] Filtered ${
        validEvents.length - nonLinkcalEvents.length
      } Linkcal events`
    );
    console.log(
      `[syncMeetings.ts] Processing ${nonLinkcalEvents.length} regular events`
    );

    // Step 2: Deduplicate events.
    const dedupedEvents = deduplicateEvents(nonLinkcalEvents);

    // Create a new Supabase client.
    const supabase = await createClient();

    // Step 3: Fetch existing meetings from the database.
    const { data: existingMeetings, error: fetchError } = await supabase
      .from("meetings")
      .select(
        "id, external_event_id, name, start_date, end_date, attendees, location, link, message, status, created_at"
      )
      .eq("linked_account_id", accountId);

    if (fetchError) {
      console.error(
        "[syncMeetings.ts] Error fetching existing meetings:",
        fetchError.message
      );
      return null;
    }

    // Step 4: Compute differences for insertion, update, and deletion.
    const insertData = computeInsertData(
      dedupedEvents,
      existingMeetings,
      accountId,
      userId
    );
    const updateData = computeUpdateData(
      dedupedEvents,
      existingMeetings,
      accountId,
      userId
    );
    const deletionIds = computeDeletions(dedupedEvents, existingMeetings);

    console.log("[syncMeetings.ts] Operations:", {
      insert: insertData.length,
      update: updateData.length,
      delete: deletionIds.length,
    });

    // Step 5a: Delete events no longer present.
    if (deletionIds.length > 0) {
      await deleteMeetings(supabase, accountId, deletionIds);
    }

    // Step 5b: Insert new events.
    if (insertData.length > 0) {
      await insertMeetings(supabase, insertData);
    }

    // Step 5c: Update events with changes.
    if (updateData.length > 0) {
      await updateMeetings(supabase, accountId, updateData);
    }

    // Step 6: Update the linked account's last_synced timestamp.
    await updateLastSynced(supabase, accountId);

    console.log("[syncMeetings.ts] Synchronization complete");
    return dedupedEvents;
  } catch (error) {
    console.error("[syncMeetings.ts] Sync error:", error);
    return null;
  }
}
